# MQTT Consumer Input Plugin

The [MQTT][mqtt] consumer plugin reads from the specified MQTT topics
and creates metrics using one of the supported [input data formats][].

### Configuration

```toml
[[inputs.mqtt_consumer]]
  ## Broker URLs for the MQTT server or cluster.  To connect to multiple
  ## clusters or standalone servers, use a seperate plugin instance.
  ##   example: servers = ["tcp://localhost:1883"]
  ##            servers = ["ssl://localhost:1883"]
  ##            servers = ["ws://localhost:1883"]
  servers = ["tcp://127.0.0.1:1883"]

  ## Topics that will be subscribed to.
  topics = [
    "telegraf/host01/cpu",
    "telegraf/+/mem",
    "sensors/#",
  ]

  ## The message topic will be stored in a tag specified by this value.  If set
  ## to the empty string no topic tag will be created.
  # topic_tag = "topic"

    ## Enabling this will allow to add measurement tags, fields and name based on
  ## the MQTT topic structure and user defined maps (see topic_column_maps for
  ## more info).
  # topic_mapper_on = true

  ## The strings defined here serve as a map for the plugin to allow decoding of
  ## MQTT topic structures. If different devices send messages with varying
  ## subtopic levels, then each topic structure will need its own map.
  ##   Example:
  ##     - "munich/house/lev1/office2/temp"
  ##       will require a map like the following, because it has 5 topic levels:
  ##       "tag:location/tag:building/tag:level/tag:room/name", which will give:
  ##       temp,location=munich,building=house,level=lev1,room=office2 value=23 1607259933097000000
  ##     - "census/portland/anderson/bees"
  ##       will require another map because it has only 4 topic levels:
  ##       "name/tag:location/tag:scientist/field:value", which will give:
  ##       census,location=portland,scientist=anderson ants=5 1607259933097000000
  ## 
  ## As seen in the example above, maps can be defined using 3 different keys:
  ## "name", "tag:tagKey" and "field:fieldKey"
  ##  - a topic level matching the "name" key in the map will be used to set the
  ##    measurement name.
  ##  - a topic level matching the "tag:tagKey" key in the map will be used to add
  ##    a new tag to the measurement, where "tagKey" can be any string and will
  ##    form the key for the tag, while the MQTT subtopic serves as the tag value.
  ##  - a topic level matching the "field:fieldKey" key in the map forms the key
  ##    of a newly created field, where fieldKey is used to find and replace fields
  ##    generated by the parser plugin selected in data_format (while preserving data).
  ##    
  ##    Example:
  ##    In case of "data_format = value" the field key should be "field:value".
  ##    In case of "data_format = json" and a JSON object of {data: 5, ID: 231}
  ##    "data" can be selected by using "field:data" at one topic level and "ID"
  ##    can be selected by using "field:ID" at another topic level. In each case
  ##    the MQTT topic level serves as the new field key, while field values are
  ##    extracted using "data" or "ID" (if these JSON fields have indeed been parsed
  ##	by the JSON parser as fields and not tags or name, etc).
  ## 
  ## Using any string not discussed above to map a subtopic will simply result
  ## in omitting that subtopic (no tags will be created from it), but they are
  ## still required as placeholders if not all levels are needed to end up in
  ## a new measurement.
  
  # topic_column_maps = [
  #   "tag:location/tag:building/tag:level/tag:room/name"
  #   "name/tag:location/tag:scientist/field:value",
  #   "n/tag:device_ID/name",
  # ]
  
  ## QoS policy for messages
  ##   0 = at most once
  ##   1 = at least once
  ##   2 = exactly once
  ##
  ## When using a QoS of 1 or 2, you should enable persistent_session to allow
  ## resuming unacknowledged messages.
  # qos = 0

  ## Connection timeout for initial connection in seconds
  # connection_timeout = "30s"

  ## Maximum messages to read from the broker that have not been written by an
  ## output.  For best throughput set based on the number of metrics within
  ## each message and the size of the output's metric_batch_size.
  ##
  ## For example, if each message from the queue contains 10 metrics and the
  ## output metric_batch_size is 1000, setting this to 100 will ensure that a
  ## full batch is collected and the write is triggered immediately without
  ## waiting until the next flush_interval.
  # max_undelivered_messages = 1000

  ## Persistent session disables clearing of the client session on connection.
  ## In order for this option to work you must also set client_id to identify
  ## the client.  To receive messages that arrived while the client is offline,
  ## also set the qos option to 1 or 2 and don't forget to also set the QoS when
  ## publishing.
  # persistent_session = false

  ## If unset, a random client ID will be generated.
  # client_id = ""

  ## Username and password to connect MQTT server.
  # username = "telegraf"
  # password = "metricsmetricsmetricsmetrics"

  ## Optional TLS Config
  # tls_ca = "/etc/telegraf/ca.pem"
  # tls_cert = "/etc/telegraf/cert.pem"
  # tls_key = "/etc/telegraf/key.pem"
  ## Use TLS but skip chain & host verification
  # insecure_skip_verify = false

  ## Data format to consume.
  ## Each data format has its own unique set of configuration options, read
  ## more about them here:
  ## https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_INPUT.md
  data_format = "influx"
```

### Metrics

- All measurements are tagged with the incoming topic, ie
`topic=telegraf/host01/cpu`

[mqtt]: https://mqtt.org
[input data formats]: /docs/DATA_FORMATS_INPUT.md
